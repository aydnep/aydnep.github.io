"use strict";(self.webpackChunk_dcentralab_web3_wallet_connector=self.webpackChunk_dcentralab_web3_wallet_connector||[]).push([[4824],{50655:(e,t,i)=>{i.d(t,{Mb:()=>st,QY:()=>oi,ZF:()=>et,i9:()=>wt,yh:()=>Wt});var s=i(17187),r=i.n(s),n=i(85150),a=i(90772),o=i(9107),h=i(28041),c=i(85094),l=i(3478),g=i(49795),d=i(37466),p=i(66736),u=i(19303),y=i(56186),b=i(93926),m=i(72307),f=i.n(m),w=i(34155);var v=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var i=new Uint8Array(256),s=0;s<i.length;s++)i[s]=255;for(var r=0;r<e.length;r++){var n=e.charAt(r),a=n.charCodeAt(0);if(255!==i[a])throw new TypeError(n+" is ambiguous");i[a]=r}var o=e.length,h=e.charAt(0),c=Math.log(o)/Math.log(256),l=Math.log(256)/Math.log(o);function g(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var s=0,r=0;e[t]===h;)s++,t++;for(var n=(e.length-t)*c+1>>>0,a=new Uint8Array(n);e[t];){var l=i[e.charCodeAt(t)];if(255===l)return;for(var g=0,d=n-1;(0!==l||g<r)&&-1!==d;d--,g++)l+=o*a[d]>>>0,a[d]=l%256>>>0,l=l/256>>>0;if(0!==l)throw new Error("Non-zero carry");r=g,t++}if(" "!==e[t]){for(var p=n-r;p!==n&&0===a[p];)p++;for(var u=new Uint8Array(s+(n-p)),y=s;p!==n;)u[y++]=a[p++];return u}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var i=0,s=0,r=0,n=t.length;r!==n&&0===t[r];)r++,i++;for(var a=(n-r)*l+1>>>0,c=new Uint8Array(a);r!==n;){for(var g=t[r],d=0,p=a-1;(0!==g||d<s)&&-1!==p;p--,d++)g+=256*c[p]>>>0,c[p]=g%o>>>0,g=g/o>>>0;if(0!==g)throw new Error("Non-zero carry");s=d,r++}for(var u=a-s;u!==a&&0===c[u];)u++;for(var y=h.repeat(i);u<a;++u)y+=e.charAt(c[u]);return y},decodeUnsafe:g,decode:function(e){var i=g(e);if(i)return i;throw new Error(`Non-${t} character`)}}};const E=e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")};class I{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class x{constructor(e,t,i){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return _(this,e)}}class P{constructor(e){this.decoders=e}or(e){return _(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const _=(e,t)=>new P({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class S{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new I(e,t,i),this.decoder=new x(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const T=({name:e,prefix:t,encode:i,decode:s})=>new S(e,t,i,s),z=({prefix:e,name:t,alphabet:i})=>{const{encode:s,decode:r}=v(i,t);return T({prefix:e,name:t,encode:s,decode:e=>E(r(e))})},R=({name:e,prefix:t,bitsPerChar:i,alphabet:s})=>T({prefix:t,name:e,encode:e=>((e,t,i)=>{const s="="===t[t.length-1],r=(1<<i)-1;let n="",a=0,o=0;for(let s=0;s<e.length;++s)for(o=o<<8|e[s],a+=8;a>i;)a-=i,n+=t[r&o>>a];if(a&&(n+=t[r&o<<i-a]),s)for(;n.length*i&7;)n+="=";return n})(e,s,i),decode:t=>((e,t,i,s)=>{const r={};for(let e=0;e<t.length;++e)r[t[e]]=e;let n=e.length;for(;"="===e[n-1];)--n;const a=new Uint8Array(n*i/8|0);let o=0,h=0,c=0;for(let t=0;t<n;++t){const n=r[e[t]];if(void 0===n)throw new SyntaxError(`Non-${s} character`);h=h<<i|n,o+=i,o>=8&&(o-=8,a[c++]=255&h>>o)}if(o>=i||255&h<<8-o)throw new SyntaxError("Unexpected end of data");return a})(t,s,i,e)}),C=T({prefix:"\0",name:"identity",encode:e=>(e=>(new TextDecoder).decode(e))(e),decode:e=>(e=>(new TextEncoder).encode(e))(e)});var O=Object.freeze({__proto__:null,identity:C});const A=R({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var L=Object.freeze({__proto__:null,base2:A});const D=R({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var N=Object.freeze({__proto__:null,base8:D});const U=z({prefix:"9",name:"base10",alphabet:"0123456789"});var M=Object.freeze({__proto__:null,base10:U});const k=R({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),K=R({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var j=Object.freeze({__proto__:null,base16:k,base16upper:K});const $=R({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),q=R({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Z=R({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),V=R({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),B=R({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),J=R({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),H=R({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),F=R({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),W=R({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Y=Object.freeze({__proto__:null,base32:$,base32upper:q,base32pad:Z,base32padupper:V,base32hex:B,base32hexupper:J,base32hexpad:H,base32hexpadupper:F,base32z:W});const G=z({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Q=z({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var X=Object.freeze({__proto__:null,base36:G,base36upper:Q});const ee=z({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),te=z({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var ie=Object.freeze({__proto__:null,base58btc:ee,base58flickr:te});const se=R({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),re=R({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),ne=R({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ae=R({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var oe=Object.freeze({__proto__:null,base64:se,base64pad:re,base64url:ne,base64urlpad:ae});const he=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),ce=he.reduce(((e,t,i)=>(e[i]=t,e)),[]),le=he.reduce(((e,t,i)=>(e[t.codePointAt(0)]=i,e)),[]);const ge=T({prefix:"🚀",name:"base256emoji",encode:function(e){return e.reduce(((e,t)=>e+=ce[t]),"")},decode:function(e){const t=[];for(const i of e){const e=le[i.codePointAt(0)];if(void 0===e)throw new Error(`Non-base256emoji character: ${i}`);t.push(e)}return new Uint8Array(t)}});var de=Object.freeze({__proto__:null,base256emoji:ge}),pe=function e(t,i,s){i=i||[];for(var r=s=s||0;t>=be;)i[s++]=255&t|ue,t/=128;for(;t&ye;)i[s++]=255&t|ue,t>>>=7;return i[s]=0|t,e.bytes=s-r+1,i},ue=128,ye=-128,be=Math.pow(2,31);var me=function e(t,i){var s,r=0,n=0,a=i=i||0,o=t.length;do{if(a>=o)throw e.bytes=0,new RangeError("Could not decode varint");s=t[a++],r+=n<28?(s&we)<<n:(s&we)*Math.pow(2,n),n+=7}while(s>=fe);return e.bytes=a-i,r},fe=128,we=127;var ve=Math.pow(2,7),Ee=Math.pow(2,14),Ie=Math.pow(2,21),xe=Math.pow(2,28),Pe=Math.pow(2,35),_e=Math.pow(2,42),Se=Math.pow(2,49),Te=Math.pow(2,56),ze=Math.pow(2,63),Re={encode:pe,decode:me,encodingLength:function(e){return e<ve?1:e<Ee?2:e<Ie?3:e<xe?4:e<Pe?5:e<_e?6:e<Se?7:e<Te?8:e<ze?9:10}};const Ce=(e,t,i=0)=>(Re.encode(e,t,i),t),Oe=e=>Re.encodingLength(e),Ae=(e,t)=>{const i=t.byteLength,s=Oe(e),r=s+Oe(i),n=new Uint8Array(r+i);return Ce(e,n,0),Ce(i,n,s),n.set(t,r),new Le(e,i,t,n)};class Le{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s}}const De=({name:e,code:t,encode:i})=>new Ne(e,t,i);class Ne{constructor(e,t,i){this.name=e,this.code=t,this.encode=i}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?Ae(this.code,t):t.then((e=>Ae(this.code,e)))}throw Error("Unknown type, must be binary type")}}const Ue=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),Me=De({name:"sha2-256",code:18,encode:Ue("SHA-256")}),ke=De({name:"sha2-512",code:19,encode:Ue("SHA-512")});Object.freeze({__proto__:null,sha256:Me,sha512:ke});const Ke=E,je={code:0,name:"identity",encode:Ke,digest:e=>Ae(0,Ke(e))};Object.freeze({__proto__:null,identity:je});new TextEncoder,new TextDecoder;const $e={...O,...L,...N,...M,...j,...Y,...X,...ie,...oe,...de};function qe(e){return null!=globalThis.Buffer?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e}function Ze(e,t,i,s){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:i},decoder:{decode:s}}}const Ve=Ze("utf8","u",(e=>"u"+new TextDecoder("utf8").decode(e)),(e=>(new TextEncoder).encode(e.substring(1)))),Be=Ze("ascii","a",(e=>{let t="a";for(let i=0;i<e.length;i++)t+=String.fromCharCode(e[i]);return t}),(e=>{const t=function(e=0){return null!=globalThis.Buffer&&null!=globalThis.Buffer.allocUnsafe?qe(globalThis.Buffer.allocUnsafe(e)):new Uint8Array(e)}((e=e.substring(1)).length);for(let i=0;i<e.length;i++)t[i]=e.charCodeAt(i);return t})),Je={utf8:Ve,"utf-8":Ve,hex:$e.base16,latin1:Be,ascii:Be,binary:Be,...$e};const He="core",Fe=`wc@2:${He}:`,We="error",Ye={database:":memory:"},Ge="client_ed25519_seed",Qe=p.ONE_DAY,Xe=p.SIX_HOURS,et="irn",tt="wss://relay.walletconnect.com",it="wss://relay.walletconnect.org",st={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},rt="payload",nt="connect",at="disconnect",ot="error",ht=p.ONE_SECOND/2,ct="subscription_created",lt="subscription_deleted",gt="subscription_sync",dt="subscription_resubscribed",pt=1e3*p.FIVE_SECONDS,ut={wc_pairingDelete:{req:{ttl:p.ONE_DAY,prompt:!1,tag:1e3},res:{ttl:p.ONE_DAY,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:p.THIRTY_SECONDS,prompt:!1,tag:1002},res:{ttl:p.THIRTY_SECONDS,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:p.ONE_DAY,prompt:!1,tag:0},res:{ttl:p.ONE_DAY,prompt:!1,tag:0}}},yt="history_created",bt="history_updated",mt="history_deleted",ft="history_sync",wt={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},vt="verify-api",Et="https://verify.walletconnect.com";class It{constructor(e,t){this.core=e,this.logger=t,this.keychain=new Map,this.name="keychain",this.version="0.3",this.initialized=!1,this.storagePrefix=Fe,this.init=async()=>{if(!this.initialized){const e=await this.getKeyChain();typeof e<"u"&&(this.keychain=e),this.initialized=!0}},this.has=e=>(this.isInitialized(),this.keychain.has(e)),this.set=async(e,t)=>{this.isInitialized(),this.keychain.set(e,t),await this.persist()},this.get=e=>{this.isInitialized();const t=this.keychain.get(e);if(typeof t>"u"){const{message:t}=(0,g.Z7)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(t)}return t},this.del=async e=>{this.isInitialized(),this.keychain.delete(e),await this.persist()},this.core=e,this.logger=(0,o.generateChildLogger)(t,this.name)}get context(){return(0,o.getLoggerContext)(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,(0,g.KC)(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?(0,g.IP)(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=(0,g.Z7)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class xt{constructor(e,t,i){this.core=e,this.logger=t,this.name="crypto",this.initialized=!1,this.init=async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)},this.hasKeys=e=>(this.isInitialized(),this.keychain.has(e)),this.getClientId=async()=>{this.isInitialized();const e=await this.getClientSeed(),t=l.generateKeyPair(e);return l.encodeIss(t.publicKey)},this.generateKeyPair=()=>{this.isInitialized();const e=(0,g.Au)();return this.setPrivateKey(e.publicKey,e.privateKey)},this.signJWT=async e=>{this.isInitialized();const t=await this.getClientSeed(),i=l.generateKeyPair(t),s=(0,g.jd)(),r=Qe;return await l.signJWT(s,e,r,i)},this.generateSharedKey=(e,t,i)=>{this.isInitialized();const s=this.getPrivateKey(e),r=(0,g.m$)(s,t);return this.setSymKey(r,i)},this.setSymKey=async(e,t)=>{this.isInitialized();const i=t||(0,g.Ym)(e);return await this.keychain.set(i,e),i},this.deleteKeyPair=async e=>{this.isInitialized(),await this.keychain.del(e)},this.deleteSymKey=async e=>{this.isInitialized(),await this.keychain.del(e)},this.encode=async(e,t,i)=>{this.isInitialized();const s=(0,g.EN)(i),r=(0,c.u)(t);if((0,g.Q8)(s)){const t=s.senderPublicKey,i=s.receiverPublicKey;e=await this.generateSharedKey(t,i)}const n=this.getSymKey(e),{type:a,senderPublicKey:o}=s;return(0,g.HI)({type:a,symKey:n,message:r,senderPublicKey:o})},this.decode=async(e,t,i)=>{this.isInitialized();const s=(0,g.Ll)(t,i);if((0,g.Q8)(s)){const t=s.receiverPublicKey,i=s.senderPublicKey;e=await this.generateSharedKey(t,i)}const r=this.getSymKey(e),n=(0,g.pe)({symKey:r,encoded:t});return(0,c.D)(n)},this.getPayloadType=e=>{const t=(0,g.vB)(e);return(0,g.WG)(t.type)},this.getPayloadSenderPublicKey=e=>{const t=(0,g.vB)(e);return t.senderPublicKey?(0,d.BB)(t.senderPublicKey,g.AW):void 0},this.core=e,this.logger=(0,o.generateChildLogger)(t,this.name),this.keychain=i||new It(this.core,this.logger)}get context(){return(0,o.getLoggerContext)(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(Ge)}catch{e=(0,g.jd)(),await this.keychain.set(Ge,e)}return function(e,t="utf8"){const i=Je[t];if(!i)throw new Error(`Unsupported encoding "${t}"`);return"utf8"!==t&&"utf-8"!==t||null==globalThis.Buffer||null==globalThis.Buffer.from?i.decoder.decode(`${i.prefix}${e}`):qe(globalThis.Buffer.from(e,"utf-8"))}(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=(0,g.Z7)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Pt extends h.kZ{constructor(e,t){super(e,t),this.logger=e,this.core=t,this.messages=new Map,this.name="messages",this.version="0.3",this.initialized=!1,this.storagePrefix=Fe,this.init=async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const e=await this.getRelayerMessages();typeof e<"u"&&(this.messages=e),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}finally{this.initialized=!0}}},this.set=async(e,t)=>{this.isInitialized();const i=(0,g.rj)(t);let s=this.messages.get(e);return typeof s>"u"&&(s={}),typeof s[i]<"u"||(s[i]=t,this.messages.set(e,s),await this.persist()),i},this.get=e=>{this.isInitialized();let t=this.messages.get(e);return typeof t>"u"&&(t={}),t},this.has=(e,t)=>{this.isInitialized();return typeof this.get(e)[(0,g.rj)(t)]<"u"},this.del=async e=>{this.isInitialized(),this.messages.delete(e),await this.persist()},this.logger=(0,o.generateChildLogger)(e,this.name),this.core=t}get context(){return(0,o.getLoggerContext)(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,(0,g.KC)(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?(0,g.IP)(e):void 0}async persist(){await this.setRelayerMessages(this.messages)}isInitialized(){if(!this.initialized){const{message:e}=(0,g.Z7)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class _t extends h.z9{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.events=new s.EventEmitter,this.name="publisher",this.queue=new Map,this.publishTimeout=(0,p.toMiliseconds)(p.TEN_SECONDS),this.queueTimeout=(0,p.toMiliseconds)(p.FIVE_SECONDS),this.needsTransportRestart=!1,this.publish=async(e,t,i)=>{this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:e,message:t,opts:i}});try{const s=i?.ttl||Xe,r=(0,g._H)(i),n=i?.prompt||!1,a=i?.tag||0,o=i?.id||(0,y.getBigIntRpcId)().toString(),h={topic:e,message:t,opts:{ttl:s,relay:r,prompt:n,tag:a,id:o}},c=setTimeout((()=>this.queue.set(o,h)),this.queueTimeout);try{await await(0,g.hF)(this.rpcPublish(e,t,s,r,n,a,o),this.publishTimeout),clearTimeout(c),this.relayer.events.emit(st.publish,h)}catch{return this.logger.debug("Publishing Payload stalled"),void(this.needsTransportRestart=!0)}this.logger.debug("Successfully Published Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:e,message:t,opts:i}})}catch(e){throw this.logger.debug("Failed to Publish Payload"),this.logger.error(e),e}},this.on=(e,t)=>{this.events.on(e,t)},this.once=(e,t)=>{this.events.once(e,t)},this.off=(e,t)=>{this.events.off(e,t)},this.removeListener=(e,t)=>{this.events.removeListener(e,t)},this.relayer=e,this.logger=(0,o.generateChildLogger)(t,this.name),this.registerEventListeners()}get context(){return(0,o.getLoggerContext)(this.logger)}rpcPublish(e,t,i,s,r,n,a){var o,h,c,l;const d={method:(0,g.cO)(s.protocol).publish,params:{topic:e,message:t,ttl:i,prompt:r,tag:n},id:a};return(0,g.o8)(null==(o=d.params)?void 0:o.prompt)&&(null==(h=d.params)||delete h.prompt),(0,g.o8)(null==(c=d.params)?void 0:c.tag)&&(null==(l=d.params)||delete l.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:d}),this.relayer.request(d)}onPublish(e){this.queue.delete(e)}checkQueue(){this.queue.forEach((async e=>{const{topic:t,message:i,opts:s}=e;await this.publish(t,i,s)}))}registerEventListeners(){this.relayer.core.heartbeat.on(a.HEARTBEAT_EVENTS.pulse,(()=>{if(this.needsTransportRestart)return this.needsTransportRestart=!1,void this.relayer.events.emit(st.connection_stalled);this.checkQueue()})),this.relayer.on(st.message_ack,(e=>{this.onPublish(e.id.toString())}))}}class St{constructor(){this.map=new Map,this.set=(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t])},this.get=e=>this.map.get(e)||[],this.exists=(e,t)=>this.get(e).includes(t),this.delete=(e,t)=>{if(typeof t>"u")return void this.map.delete(e);if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter((e=>e!==t));s.length?this.map.set(e,s):this.map.delete(e)},this.clear=()=>{this.map.clear()}}get topics(){return Array.from(this.map.keys())}}var Tt=Object.defineProperty,zt=Object.defineProperties,Rt=Object.getOwnPropertyDescriptors,Ct=Object.getOwnPropertySymbols,Ot=Object.prototype.hasOwnProperty,At=Object.prototype.propertyIsEnumerable,Lt=(e,t,i)=>t in e?Tt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Dt=(e,t)=>{for(var i in t||(t={}))Ot.call(t,i)&&Lt(e,i,t[i]);if(Ct)for(var i of Ct(t))At.call(t,i)&&Lt(e,i,t[i]);return e},Nt=(e,t)=>zt(e,Rt(t));class Ut extends h.sY{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.subscriptions=new Map,this.topicMap=new St,this.events=new s.EventEmitter,this.name="subscription",this.version="0.3",this.pending=new Map,this.cached=[],this.initialized=!1,this.pendingSubscriptionWatchLabel="pending_sub_watch_label",this.pollingInterval=20,this.storagePrefix=Fe,this.subscribeTimeout=1e4,this.restartInProgress=!1,this.batchSubscribeTopicsLimit=500,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restart(),this.registerEventListeners(),this.onEnable(),this.clientId=await this.relayer.core.crypto.getClientId())},this.subscribe=async(e,t)=>{await this.restartToComplete(),this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:e,opts:t}});try{const i=(0,g._H)(t),s={topic:e,relay:i};this.pending.set(e,s);const r=await this.rpcSubscribe(e,i);return this.onSubscribe(r,s),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:e,opts:t}}),r}catch(e){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(e),e}},this.unsubscribe=async(e,t)=>{await this.restartToComplete(),this.isInitialized(),typeof t?.id<"u"?await this.unsubscribeById(e,t.id,t):await this.unsubscribeByTopic(e,t)},this.isSubscribed=async e=>!!this.topics.includes(e)||await new Promise(((t,i)=>{const s=new p.Watch;s.start(this.pendingSubscriptionWatchLabel);const r=setInterval((()=>{!this.pending.has(e)&&this.topics.includes(e)&&(clearInterval(r),s.stop(this.pendingSubscriptionWatchLabel),t(!0)),s.elapsed(this.pendingSubscriptionWatchLabel)>=pt&&(clearInterval(r),s.stop(this.pendingSubscriptionWatchLabel),i(new Error("Subscription resolution timeout")))}),this.pollingInterval)})).catch((()=>!1)),this.on=(e,t)=>{this.events.on(e,t)},this.once=(e,t)=>{this.events.once(e,t)},this.off=(e,t)=>{this.events.off(e,t)},this.removeListener=(e,t)=>{this.events.removeListener(e,t)},this.restart=async()=>{this.restartInProgress=!0,await this.restore(),await this.reset(),this.restartInProgress=!1},this.relayer=e,this.logger=(0,o.generateChildLogger)(t,this.name),this.clientId=""}get context(){return(0,o.getLoggerContext)(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t}catch{}return i}onEnable(){this.cached=[],this.initialized=!0}onDisable(){this.cached=this.values,this.subscriptions.clear(),this.topicMap.clear()}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map((async i=>await this.unsubscribeById(e,i,t))))}async unsubscribeById(e,t,i){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});try{const s=(0,g._H)(i);await this.rpcUnsubscribe(e,t,s);const r=(0,g.D6)("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,r),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}})}catch(e){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(e),e}}async rpcSubscribe(e,t){const i={method:(0,g.cO)(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{await await(0,g.hF)(this.relayer.request(i),this.subscribeTimeout)}catch{this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(st.connection_stalled)}return(0,g.rj)(e+this.clientId)}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,i={method:(0,g.cO)(t.protocol).batchSubscribe,params:{topics:e.map((e=>e.topic))}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{return await await(0,g.hF)(this.relayer.request(i),this.subscribeTimeout)}catch{this.logger.debug("Outgoing Relay Payload stalled"),this.relayer.events.emit(st.connection_stalled)}}rpcUnsubscribe(e,t,i){const s={method:(0,g.cO)(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s}),this.relayer.request(s)}onSubscribe(e,t){this.setSubscription(e,Nt(Dt({},t),{id:e})),this.pending.delete(t.topic)}onBatchSubscribe(e){e.length&&e.forEach((e=>{this.setSubscription(e.id,Dt({},e)),this.pending.delete(e.topic)}))}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.subscriptions.has(e)||(this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t))}addSubscription(e,t){this.subscriptions.set(e,Dt({},t)),this.topicMap.set(t.topic,e),this.events.emit(ct,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:t}=(0,g.Z7)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(t)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(lt,Nt(Dt({},i),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(gt)}async reset(){if(this.cached.length){const e=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let t=0;t<e;t++){const e=this.cached.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(e)}}this.events.emit(dt)}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:e}=(0,g.Z7)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(e),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(e)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async batchSubscribe(e){if(!e.length)return;const t=await this.rpcBatchSubscribe(e);(0,g.qt)(t)&&this.onBatchSubscribe(t.map(((t,i)=>Nt(Dt({},e[i]),{id:t}))))}async onConnect(){this.restartInProgress||(await this.restart(),this.onEnable())}onDisconnect(){this.onDisable()}async checkPending(){if(this.relayer.transportExplicitlyClosed)return;const e=[];this.pending.forEach((t=>{e.push(t)})),await this.batchSubscribe(e)}registerEventListeners(){this.relayer.core.heartbeat.on(a.HEARTBEAT_EVENTS.pulse,(async()=>{await this.checkPending()})),this.relayer.on(st.connect,(async()=>{await this.onConnect()})),this.relayer.on(st.disconnect,(()=>{this.onDisconnect()})),this.events.on(ct,(async e=>{const t=ct;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()})),this.events.on(lt,(async e=>{const t=lt;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()}))}isInitialized(){if(!this.initialized){const{message:e}=(0,g.Z7)("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(){this.restartInProgress&&await new Promise((e=>{const t=setInterval((()=>{this.restartInProgress||(clearInterval(t),e())}),this.pollingInterval)}))}}var Mt=Object.defineProperty,kt=Object.getOwnPropertySymbols,Kt=Object.prototype.hasOwnProperty,jt=Object.prototype.propertyIsEnumerable,$t=(e,t,i)=>t in e?Mt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i;class qt extends h.oe{constructor(e){super(e),this.protocol="wc",this.version=2,this.events=new s.EventEmitter,this.name="relayer",this.transportExplicitlyClosed=!1,this.initialized=!1,this.reconnecting=!1,this.connectionStatusPollingInterval=20,this.staleConnectionErrors=["socket hang up","socket stalled"],this.request=async e=>{this.logger.debug("Publishing Request Payload");try{return await this.toEstablishConnection(),await this.provider.request(e)}catch(e){throw this.logger.debug("Failed to Publish Request"),this.logger.error(e),e}},this.core=e.core,this.logger=typeof e.logger<"u"&&"string"!=typeof e.logger?(0,o.generateChildLogger)(e.logger,this.name):(0,o.pino)((0,o.getDefaultLoggerOptions)({level:e.logger||"error"})),this.messages=new Pt(this.logger,e.core),this.subscriber=new Ut(this,this.logger),this.publisher=new _t(this,this.logger),this.relayUrl=e?.relayUrl||tt,this.projectId=e.projectId,this.provider={}}async init(){this.logger.trace("Initialized"),await this.createProvider(),await Promise.all([this.messages.init(),this.subscriber.init()]);try{await this.transportOpen()}catch{this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${it}...`),await this.restartTransport(it)}this.registerEventListeners(),this.initialized=!0,setTimeout((async()=>{0===this.subscriber.topics.length&&(this.logger.info("No topics subscribed to after init, closing transport"),await this.transportClose(),this.transportExplicitlyClosed=!1)}),1e4)}get context(){return(0,o.getLoggerContext)(this.logger)}get connected(){return this.provider.connection.connected}get connecting(){return this.provider.connection.connecting}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now()})}async subscribe(e,t){var i;this.isInitialized();let s=(null==(i=this.subscriber.topicMap.get(e))?void 0:i[0])||"";return s||(await Promise.all([new Promise((t=>{this.subscriber.once(ct,(i=>{i.topic===e&&t()}))})),new Promise((async i=>{s=await this.subscriber.subscribe(e,t),i()}))]),s)}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}async transportClose(){this.transportExplicitlyClosed=!0,this.connected&&(await this.provider.disconnect(),this.events.emit(st.transport_closed))}async transportOpen(e){if(this.transportExplicitlyClosed=!1,!this.reconnecting){this.relayUrl=e||this.relayUrl,this.reconnecting=!0;try{await Promise.all([new Promise((e=>{this.initialized||e(),this.subscriber.once(dt,(()=>{e()}))})),await Promise.race([new Promise((async(e,t)=>{await(0,g.hF)(this.provider.connect(),5e3,`Socket stalled when trying to connect to ${this.relayUrl}`).catch((e=>t(e))).then((()=>e())).finally((()=>this.removeListener(st.transport_closed,this.rejectTransportOpen)))})),new Promise((e=>this.once(st.transport_closed,this.rejectTransportOpen)))])])}catch(e){this.logger.error(e);const t=e;if(!this.isConnectionStalled(t.message))throw e;this.events.emit(st.transport_closed)}finally{this.reconnecting=!1}}}async restartTransport(e){this.transportExplicitlyClosed||this.reconnecting||(this.relayUrl=e||this.relayUrl,this.connected&&await Promise.all([new Promise((e=>{this.provider.once(at,(()=>{e()}))})),this.transportClose()]),await this.createProvider(),await this.transportOpen())}isConnectionStalled(e){return this.staleConnectionErrors.some((t=>e.includes(t)))}rejectTransportOpen(){throw new Error("Attempt to connect to relay via `transportOpen` has stalled. Retrying...")}async createProvider(){const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new u.r(new b.Z((0,g.$0)({sdkVersion:"2.8.6",protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0}))),this.registerProviderListeners()}async recordMessageEvent(e){const{topic:t,message:i}=e;await this.messages.set(t,i)}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;return!await this.subscriber.isSubscribed(t)||this.messages.has(t,i)}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),(0,y.isJsonRpcRequest)(e)){if(!e.method.endsWith("_subscription"))return;const t=e.params,{topic:i,message:s,publishedAt:r}=t.data,n={topic:i,message:s,publishedAt:r};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(((e,t)=>{for(var i in t||(t={}))Kt.call(t,i)&&$t(e,i,t[i]);if(kt)for(var i of kt(t))jt.call(t,i)&&$t(e,i,t[i]);return e})({type:"event",event:t.id},n)),this.events.emit(t.id,n),await this.acknowledgePayload(e),await this.onMessageEvent(n)}else(0,y.isJsonRpcResponse)(e)&&this.events.emit(st.message_ack,e)}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(this.events.emit(st.message,e),await this.recordMessageEvent(e))}async acknowledgePayload(e){const t=(0,y.formatJsonRpcResult)(e.id,!0);await this.provider.connection.send(t)}registerProviderListeners(){this.provider.on(rt,(e=>this.onProviderPayload(e))),this.provider.on(nt,(()=>{this.events.emit(st.connect)})),this.provider.on(at,(()=>{this.onProviderDisconnect()})),this.provider.on(ot,(e=>{this.logger.error(e),this.events.emit(st.error,e)}))}registerEventListeners(){this.events.on(st.connection_stalled,(async()=>{await this.restartTransport()}))}onProviderDisconnect(){this.events.emit(st.disconnect),this.attemptToReconnect()}attemptToReconnect(){this.transportExplicitlyClosed||setTimeout((async()=>{await this.restartTransport()}),(0,p.toMiliseconds)(ht))}isInitialized(){if(!this.initialized){const{message:e}=(0,g.Z7)("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){if(!this.connected){if(this.connecting)return await new Promise((e=>{const t=setInterval((()=>{this.connected&&(clearInterval(t),e())}),this.connectionStatusPollingInterval)}));await this.restartTransport()}}}var Zt=Object.defineProperty,Vt=Object.getOwnPropertySymbols,Bt=Object.prototype.hasOwnProperty,Jt=Object.prototype.propertyIsEnumerable,Ht=(e,t,i)=>t in e?Zt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,Ft=(e,t)=>{for(var i in t||(t={}))Bt.call(t,i)&&Ht(e,i,t[i]);if(Vt)for(var i of Vt(t))Jt.call(t,i)&&Ht(e,i,t[i]);return e};class Wt extends h.pZ{constructor(e,t,i,s=Fe,r=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,this.map=new Map,this.version="0.3",this.cached=[],this.initialized=!1,this.storagePrefix=Fe,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach((e=>{this.getKey&&null!==e&&!(0,g.o8)(e)?this.map.set(this.getKey(e),e):(0,g.xW)(e)?this.map.set(e.id,e):(0,g.h1)(e)&&this.map.set(e.topic,e)})),this.cached=[],this.initialized=!0)},this.set=async(e,t)=>{this.isInitialized(),this.map.has(e)?await this.update(e,t):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:e,value:t}),this.map.set(e,t),await this.persist())},this.get=e=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:e}),this.getData(e)),this.getAll=e=>(this.isInitialized(),e?this.values.filter((t=>Object.keys(e).every((i=>f()(t[i],e[i]))))):this.values),this.update=async(e,t)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:e,update:t});const i=Ft(Ft({},this.getData(e)),t);this.map.set(e,i),await this.persist()},this.delete=async(e,t)=>{this.isInitialized(),this.map.has(e)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:e,reason:t}),this.map.delete(e),await this.persist())},this.logger=(0,o.generateChildLogger)(t,this.name),this.storagePrefix=s,this.getKey=r}get context(){return(0,o.getLoggerContext)(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){const{message:t}=(0,g.Z7)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(t),new Error(t)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:e}=(0,g.Z7)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(e),new Error(e)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=(0,g.Z7)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Yt{constructor(e,t){this.core=e,this.logger=t,this.name="pairing",this.version="0.3",this.events=new(r()),this.initialized=!1,this.storagePrefix=Fe,this.ignoredPayloadTypes=[g.rV],this.registeredMethods=[],this.init=async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))},this.register=({methods:e})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...e])]},this.create=async()=>{this.isInitialized();const e=(0,g.jd)(),t=await this.core.crypto.setSymKey(e),i=(0,g.gn)(p.FIVE_MINUTES),s={protocol:et},r={topic:t,expiry:i,relay:s,active:!1},n=(0,g.Bv)({protocol:this.core.protocol,version:this.core.version,topic:t,symKey:e,relay:s});return await this.pairings.set(t,r),await this.core.relayer.subscribe(t),this.core.expirer.set(t,i),{topic:t,uri:n}},this.pair=async e=>{this.isInitialized(),this.isValidPair(e);const{topic:t,symKey:i,relay:s}=(0,g.he)(e.uri);if(this.pairings.keys.includes(t))throw new Error(`Pairing already exists: ${t}`);if(this.core.crypto.hasKeys(t))throw new Error(`Keychain already exists: ${t}`);const r=(0,g.gn)(p.FIVE_MINUTES),n={topic:t,relay:s,expiry:r,active:!1};return await this.pairings.set(t,n),await this.core.crypto.setSymKey(i,t),await this.core.relayer.subscribe(t,{relay:s}),this.core.expirer.set(t,r),e.activatePairing&&await this.activate({topic:t}),n},this.activate=async({topic:e})=>{this.isInitialized();const t=(0,g.gn)(p.THIRTY_DAYS);await this.pairings.update(e,{active:!0,expiry:t}),this.core.expirer.set(e,t)},this.ping=async e=>{this.isInitialized(),await this.isValidPing(e);const{topic:t}=e;if(this.pairings.keys.includes(t)){const e=await this.sendRequest(t,"wc_pairingPing",{}),{done:i,resolve:s,reject:r}=(0,g.H1)();this.events.once((0,g.E0)("pairing_ping",e),(({error:e})=>{e?r(e):s()})),await i()}},this.updateExpiry=async({topic:e,expiry:t})=>{this.isInitialized(),await this.pairings.update(e,{expiry:t})},this.updateMetadata=async({topic:e,metadata:t})=>{this.isInitialized(),await this.pairings.update(e,{peerMetadata:t})},this.getPairings=()=>(this.isInitialized(),this.pairings.values),this.disconnect=async e=>{this.isInitialized(),await this.isValidDisconnect(e);const{topic:t}=e;this.pairings.keys.includes(t)&&(await this.sendRequest(t,"wc_pairingDelete",(0,g.D6)("USER_DISCONNECTED")),await this.deletePairing(t))},this.sendRequest=async(e,t,i)=>{const s=(0,y.formatJsonRpcRequest)(t,i),r=await this.core.crypto.encode(e,s),n=ut[t].req;return this.core.history.set(e,s),this.core.relayer.publish(e,r,n),s.id},this.sendResult=async(e,t,i)=>{const s=(0,y.formatJsonRpcResult)(e,i),r=await this.core.crypto.encode(t,s),n=await this.core.history.get(t,e),a=ut[n.request.method].res;await this.core.relayer.publish(t,r,a),await this.core.history.resolve(s)},this.sendError=async(e,t,i)=>{const s=(0,y.formatJsonRpcError)(e,i),r=await this.core.crypto.encode(t,s),n=await this.core.history.get(t,e),a=ut[n.request.method]?ut[n.request.method].res:ut.unregistered_method.res;await this.core.relayer.publish(t,r,a),await this.core.history.resolve(s)},this.deletePairing=async(e,t)=>{await this.core.relayer.unsubscribe(e),await Promise.all([this.pairings.delete(e,(0,g.D6)("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(e),t?Promise.resolve():this.core.expirer.del(e)])},this.cleanup=async()=>{const e=this.pairings.getAll().filter((e=>(0,g.Bw)(e.expiry)));await Promise.all(e.map((e=>this.deletePairing(e.topic))))},this.onRelayEventRequest=e=>{const{topic:t,payload:i}=e,s=i.method;if(this.pairings.keys.includes(t))switch(s){case"wc_pairingPing":return this.onPairingPingRequest(t,i);case"wc_pairingDelete":return this.onPairingDeleteRequest(t,i);default:return this.onUnknownRpcMethodRequest(t,i)}},this.onRelayEventResponse=async e=>{const{topic:t,payload:i}=e,s=(await this.core.history.get(t,i.id)).request.method;if(this.pairings.keys.includes(t)){if("wc_pairingPing"===s)return this.onPairingPingResponse(t,i);return this.onUnknownRpcMethodResponse(s)}},this.onPairingPingRequest=async(e,t)=>{const{id:i}=t;try{this.isValidPing({topic:e}),await this.sendResult(i,e,!0),this.events.emit("pairing_ping",{id:i,topic:e})}catch(t){await this.sendError(i,e,t),this.logger.error(t)}},this.onPairingPingResponse=(e,t)=>{const{id:i}=t;setTimeout((()=>{(0,y.isJsonRpcResult)(t)?this.events.emit((0,g.E0)("pairing_ping",i),{}):(0,y.isJsonRpcError)(t)&&this.events.emit((0,g.E0)("pairing_ping",i),{error:t.error})}),500)},this.onPairingDeleteRequest=async(e,t)=>{const{id:i}=t;try{this.isValidDisconnect({topic:e}),await this.deletePairing(e),this.events.emit("pairing_delete",{id:i,topic:e})}catch(t){await this.sendError(i,e,t),this.logger.error(t)}},this.onUnknownRpcMethodRequest=async(e,t)=>{const{id:i,method:s}=t;try{if(this.registeredMethods.includes(s))return;const t=(0,g.D6)("WC_METHOD_UNSUPPORTED",s);await this.sendError(i,e,t),this.logger.error(t)}catch(t){await this.sendError(i,e,t),this.logger.error(t)}},this.onUnknownRpcMethodResponse=e=>{this.registeredMethods.includes(e)||this.logger.error((0,g.D6)("WC_METHOD_UNSUPPORTED",e))},this.isValidPair=e=>{if(!(0,g.EJ)(e)){const{message:t}=(0,g.Z7)("MISSING_OR_INVALID",`pair() params: ${e}`);throw new Error(t)}if(!(0,g.jv)(e.uri)){const{message:t}=(0,g.Z7)("MISSING_OR_INVALID",`pair() uri: ${e.uri}`);throw new Error(t)}},this.isValidPing=async e=>{if(!(0,g.EJ)(e)){const{message:t}=(0,g.Z7)("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(t)}const{topic:t}=e;await this.isValidPairingTopic(t)},this.isValidDisconnect=async e=>{if(!(0,g.EJ)(e)){const{message:t}=(0,g.Z7)("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(t)}const{topic:t}=e;await this.isValidPairingTopic(t)},this.isValidPairingTopic=async e=>{if(!(0,g.M_)(e,!1)){const{message:t}=(0,g.Z7)("MISSING_OR_INVALID",`pairing topic should be a string: ${e}`);throw new Error(t)}if(!this.pairings.keys.includes(e)){const{message:t}=(0,g.Z7)("NO_MATCHING_KEY",`pairing topic doesn't exist: ${e}`);throw new Error(t)}if((0,g.Bw)(this.pairings.get(e).expiry)){await this.deletePairing(e);const{message:t}=(0,g.Z7)("EXPIRED",`pairing topic: ${e}`);throw new Error(t)}},this.core=e,this.logger=(0,o.generateChildLogger)(t,this.name),this.pairings=new Wt(this.core,this.logger,this.name,this.storagePrefix)}get context(){return(0,o.getLoggerContext)(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=(0,g.Z7)("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(st.message,(async e=>{const{topic:t,message:i}=e;if(this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))return;const s=await this.core.crypto.decode(t,i);(0,y.isJsonRpcRequest)(s)?(this.core.history.set(t,s),this.onRelayEventRequest({topic:t,payload:s})):(0,y.isJsonRpcResponse)(s)&&(await this.core.history.resolve(s),await this.onRelayEventResponse({topic:t,payload:s}),this.core.history.delete(t,s.id))}))}registerExpirerEvents(){this.core.expirer.on(wt.expired,(async e=>{const{topic:t}=(0,g.iP)(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit("pairing_expire",{topic:t}))}))}}class Gt extends h.yy{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.records=new Map,this.events=new s.EventEmitter,this.name="history",this.version="0.3",this.cached=[],this.initialized=!1,this.storagePrefix=Fe,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach((e=>this.records.set(e.id,e))),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.set=(e,t,i)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:e,request:t,chainId:i}),this.records.has(t.id))return;const s={id:t.id,topic:e,request:{method:t.method,params:t.params||null},chainId:i,expiry:(0,g.gn)(p.THIRTY_DAYS)};this.records.set(s.id,s),this.events.emit(yt,s)},this.resolve=async e=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:e}),!this.records.has(e.id))return;const t=await this.getRecord(e.id);typeof t.response>"u"&&(t.response=(0,y.isJsonRpcError)(e)?{error:e.error}:{result:e.result},this.records.set(t.id,t),this.events.emit(bt,t))},this.get=async(e,t)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:e,id:t}),await this.getRecord(t)),this.delete=(e,t)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:t}),this.values.forEach((i=>{if(i.topic===e){if(typeof t<"u"&&i.id!==t)return;this.records.delete(i.id),this.events.emit(mt,i)}}))},this.exists=async(e,t)=>(this.isInitialized(),!!this.records.has(t)&&(await this.getRecord(t)).topic===e),this.on=(e,t)=>{this.events.on(e,t)},this.once=(e,t)=>{this.events.once(e,t)},this.off=(e,t)=>{this.events.off(e,t)},this.removeListener=(e,t)=>{this.events.removeListener(e,t)},this.logger=(0,o.generateChildLogger)(t,this.name)}get context(){return(0,o.getLoggerContext)(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach((t=>{if(typeof t.response<"u")return;const i={topic:t.topic,request:(0,y.formatJsonRpcRequest)(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)})),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:t}=(0,g.Z7)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(t)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(ft)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:e}=(0,g.Z7)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(e),new Error(e)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(yt,(e=>{const t=yt;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()})),this.events.on(bt,(e=>{const t=bt;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()})),this.events.on(mt,(e=>{const t=mt;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()})),this.core.heartbeat.on(a.HEARTBEAT_EVENTS.pulse,(()=>{this.cleanup()}))}cleanup(){try{this.records.forEach((e=>{(0,p.toMiliseconds)(e.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${e.id}`),this.delete(e.topic,e.id))}))}catch(e){this.logger.warn(e)}}isInitialized(){if(!this.initialized){const{message:e}=(0,g.Z7)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Qt extends h.D3{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.expirations=new Map,this.events=new s.EventEmitter,this.name="expirer",this.version="0.3",this.cached=[],this.initialized=!1,this.storagePrefix=Fe,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach((e=>this.expirations.set(e.target,e))),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.has=e=>{try{const t=this.formatTarget(e);return typeof this.getExpiration(t)<"u"}catch{return!1}},this.set=(e,t)=>{this.isInitialized();const i=this.formatTarget(e),s={target:i,expiry:t};this.expirations.set(i,s),this.checkExpiry(i,s),this.events.emit(wt.created,{target:i,expiration:s})},this.get=e=>{this.isInitialized();const t=this.formatTarget(e);return this.getExpiration(t)},this.del=e=>{if(this.isInitialized(),this.has(e)){const t=this.formatTarget(e),i=this.getExpiration(t);this.expirations.delete(t),this.events.emit(wt.deleted,{target:t,expiration:i})}},this.on=(e,t)=>{this.events.on(e,t)},this.once=(e,t)=>{this.events.once(e,t)},this.off=(e,t)=>{this.events.off(e,t)},this.removeListener=(e,t)=>{this.events.removeListener(e,t)},this.logger=(0,o.generateChildLogger)(t,this.name)}get context(){return(0,o.getLoggerContext)(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if("string"==typeof e)return(0,g.Z4)(e);if("number"==typeof e)return(0,g.Gq)(e);const{message:t}=(0,g.Z7)("UNKNOWN_TYPE","Target type: "+typeof e);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(wt.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:e}=(0,g.Z7)("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(e),new Error(e)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:t}=(0,g.Z7)("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(t),new Error(t)}return t}checkExpiry(e,t){const{expiry:i}=t;(0,p.toMiliseconds)(i)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(wt.expired,{target:e,expiration:t})}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach(((e,t)=>this.checkExpiry(t,e)))}registerEventListeners(){this.core.heartbeat.on(a.HEARTBEAT_EVENTS.pulse,(()=>this.checkExpirations())),this.events.on(wt.created,(e=>{const t=wt.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})),this.events.on(wt.expired,(e=>{const t=wt.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})),this.events.on(wt.deleted,(e=>{const t=wt.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}))}isInitialized(){if(!this.initialized){const{message:e}=(0,g.Z7)("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Xt extends h.Yo{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,this.name=vt,this.initialized=!1,this.init=async e=>{(0,g.b$)()||!(0,g.jU)()||(this.verifyUrl=e?.verifyUrl||Et,await this.createIframe())},this.register=async e=>{var t;if(this.initialized||await this.init(),this.iframe)try{null==(t=this.iframe.contentWindow)||t.postMessage(e.attestationId,this.verifyUrl),this.logger.info(`postMessage sent: ${e.attestationId} ${this.verifyUrl}`)}catch{}},this.resolve=async e=>{var t;if(this.isDevEnv)return"";this.logger.info(`resolving attestation: ${e.attestationId}`);const i=this.startAbortTimer(p.FIVE_SECONDS),s=await fetch(`${this.verifyUrl}/attestation/${e.attestationId}`,{signal:this.abortController.signal});return clearTimeout(i),200===s.status?null==(t=await s.json())?void 0:t.origin:""},this.createIframe=async()=>{try{await Promise.race([new Promise(((e,t)=>{if(document.getElementById(vt))return e();const i=document.createElement("iframe");i.setAttribute("id",vt),i.setAttribute("src",`${this.verifyUrl}/${this.projectId}`),i.style.display="none",i.addEventListener("load",(()=>{this.initialized=!0,e()})),i.addEventListener("error",(e=>{t(e)})),document.body.append(i),this.iframe=i})),new Promise((e=>{setTimeout((()=>e("iframe load timeout")),(0,p.toMiliseconds)(p.ONE_SECOND/2))}))])}catch(e){this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`),this.logger.error(e)}},this.logger=(0,o.generateChildLogger)(t,this.name),this.verifyUrl=Et,this.abortController=new AbortController,this.isDevEnv=(0,g.UG)()&&w.env.IS_VITEST}get context(){return(0,o.getLoggerContext)(this.logger)}startAbortTimer(e){return setTimeout((()=>this.abortController.abort()),(0,p.toMiliseconds)(e))}}var ei=Object.defineProperty,ti=Object.getOwnPropertySymbols,ii=Object.prototype.hasOwnProperty,si=Object.prototype.propertyIsEnumerable,ri=(e,t,i)=>t in e?ei(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,ni=(e,t)=>{for(var i in t||(t={}))ii.call(t,i)&&ri(e,i,t[i]);if(ti)for(var i of ti(t))si.call(t,i)&&ri(e,i,t[i]);return e};class ai extends h.N1{constructor(e){super(e),this.protocol="wc",this.version=2,this.name=He,this.events=new s.EventEmitter,this.initialized=!1,this.on=(e,t)=>this.events.on(e,t),this.once=(e,t)=>this.events.once(e,t),this.off=(e,t)=>this.events.off(e,t),this.removeListener=(e,t)=>this.events.removeListener(e,t),this.projectId=e?.projectId,this.relayUrl=e?.relayUrl||tt;const t=typeof e?.logger<"u"&&"string"!=typeof e?.logger?e.logger:(0,o.pino)((0,o.getDefaultLoggerOptions)({level:e?.logger||We}));this.logger=(0,o.generateChildLogger)(t,this.name),this.heartbeat=new a.HeartBeat,this.crypto=new xt(this,this.logger,e?.keychain),this.history=new Gt(this,this.logger),this.expirer=new Qt(this,this.logger),this.storage=null!=e&&e.storage?e.storage:new n.ZP(ni(ni({},Ye),e?.storageOptions)),this.relayer=new qt({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new Yt(this,this.logger),this.verify=new Xt(this.projectId||"",this.logger)}static async init(e){const t=new ai(e);await t.initialize();const i=await t.crypto.getClientId();return await t.storage.setItem("WALLETCONNECT_CLIENT_ID",i),t}get context(){return(0,o.getLoggerContext)(this.logger)}async start(){this.initialized||await this.initialize()}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.initialized=!0,this.logger.info("Core Initialization Success")}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}}const oi=ai}}]);